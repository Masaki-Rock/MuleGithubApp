/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package mule.ci.tool.app;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.DefaultParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import mule.ci.tool.app.api.GithubAPICaller;
import mule.ci.tool.app.api.model.GithubReleaseResponse;
import mule.ci.tool.app.util.AppException;
import mule.ci.tool.app.util.Const;

public class App {

	private static final Logger log = LoggerFactory.getLogger(App.class);

    public static void main(String[] args) {
		try {
			CommandLine line = setMenue(args);
			taskControler(line);
		} catch (AppException e) {
			log.error(e.getMessage());
		}
    }
    
	/**
	 * サービスメニュー設定処理
	 * 
	 * @param args 引数
	 * @return 実行コマンド解析結果
	 * @throws AppException アプリケーション例外
	 */
	private static CommandLine setMenue(String[] args) throws AppException {

		CommandLineParser parser = new DefaultParser();
		CommandLine line = null;
		try {
			line = parser.parse(setOptions(), args);
		} catch (ParseException e) {
			throw new AppException(e);
		}
		return line;
	}
	
	/**
	 * 提供サービス
	 * 
	 * @return サービス群
	 */
	private static Options setOptions() {
		Options options = new Options();
		options.addOption("help", false, "Show all menue.");
		options.addOption("upload", false,"Upload the application file to the release folder.");
		options.addOption("download", false,"Download the application file from the release folder.");
		options.addOption("config", true, "Specifying the path of the project configuration file.");
		options.addOption("release", true, "Specify the release folder.");
		options.addOption("pre", true, "Specify the pre-release.");
		options.addOption("branch", true, "Specify the target brunch.");
		options.addOption("artifact", true, "Specify the github application name.");
		options.addOption("token", true, "Specify GITHUB_TOKEN..");
		return options;
	}
	
	/**
	 * サービス実行制御
	 * 
	 * @param line 実行コマンド
	 * @throws AppException アプリケーション例外
	 */
	private static void taskControler(CommandLine line) throws AppException {

		executeSettingsMenue(line);
		executeGithubMenue(line);
		if (line.hasOption("help")) {
			HelpFormatter formatter = new HelpFormatter();
			formatter.printHelp("Github Tool", setOptions());
		}
	}
	
	/**
	 * 設定メニュー
	 * @param line コマンドライン
	 * @throws AppException アプリケーション例外
	 */
	private static void executeSettingsMenue(CommandLine line) throws AppException {

		if (line.hasOption("config")) {
			String projectpath = line.getOptionValue("config");
			Path projectfile = Paths.get(projectpath);
			log.info("Project HOME path is {}", projectpath);
			if (!projectfile.toFile().exists()) {
				throw new AppException(String.format("{} Project POM file does not exist.", projectfile.toString()));
			}
			Const.PROJECT_HOME = projectfile.toString();
		}
		Const.init();
		if (line.hasOption("release")) {
			String foldername = line.getOptionValue("release");
			Const.RELEASE_NAME = foldername;
			log.info("Github Release folder is {}.", foldername);
		}
		if (line.hasOption("pre")) {
			String preReleaseFlag = line.getOptionValue("pre");
			if (StringUtils.isNoneBlank(preReleaseFlag)) {
				Const.PRERELEASE_FLAG = false;
			}
			log.info("Github Pre-Release Flag is {}.", preReleaseFlag);
		}
		if (line.hasOption("branch")) {
			String branch = line.getOptionValue("branch");
			Const.BRANCH = branch;
			log.info("Github Branch is {}.", branch);
		}
		if (line.hasOption("artifact")) {
			String filePath = line.getOptionValue("artifact");
			Const.ARTIFACT_NAME = filePath;
			log.info("Github Application file is {}.", Const.ARTIFACT_NAME);
		}
		if (line.hasOption("token")) {
			String token = line.getOptionValue("token");
			Const.ACCESS_TOKEN = token;
			log.info("Github token is setted.");
		}
	}
	
	/**
	 * GitHubメニュー
	 * @param line コマンドライン
	 * @throws AppException アプリケーション
	 */
	private static void executeGithubMenue(CommandLine line) throws AppException {
		
		if (line.hasOption("upload")) {
			log.info("git Upload process start!!");
			uploadApplicationFile();
			log.info("git Upload process finished!!");
		}
		if (line.hasOption("download")) {
			log.info("git Download process start!!");
			downloadApplicationFile();
			log.info("git Download process finished!!");
		}
	}
	
	/**
	 * リリースフォルダへアプリケーションファイルアップロード機能
	 * 
	 * @throws AppException アプリケーション例外
	 */
	public static void uploadApplicationFile() throws AppException {

		GithubAPICaller caller = new GithubAPICaller();
		GithubReleaseResponse release = caller.getRelease(Const.RELEASE_NAME);
		if (release == null) {
			release = caller.saveRelease(Const.RELEASE_NAME, Const.PRERELEASE_FLAG, Const.BRANCH);
		}
		Calendar cl = Calendar.getInstance();
		SimpleDateFormat sdf = new SimpleDateFormat("MMddHHmmss");
		String filename = String.format(Const.APPLICATION_FILE_NAME, sdf.format(cl.getTime()));
		caller.saveAssets(release.getId(), Const.APPLICATION_FILE_PATH, filename);
	}
	
	/**
	 * アプリケーションダウンロード機能
	 * 
	 * @return ダウンロードファイル名
	 * @throws AppException アプリケーション例外
	 */
	public static String downloadApplicationFile() throws AppException {

		GithubAPICaller caller = new GithubAPICaller();
		List<Map<String, Object>> assets = caller.findAsset(Const.RELEASE_NAME);
		List<String> fnamelist = new ArrayList<String>();
		String expr = String.format(Const.APPLICATION_FILE_NAME, "[\\d]+\\");
		for (Map<String, Object> asset: assets) {
			String filename = (String) asset.get("name");
			if (filename.matches(expr)) {
				fnamelist.add(filename);
			}
		}
		Collections.reverse(fnamelist);
		if (fnamelist.isEmpty()) {
			return null;
		}
		String filepath = fnamelist.get(0);
		if (StringUtils.isNotBlank(Const.ARTIFACT_NAME)) {
			filepath = Const.ARTIFACT_NAME;
		}
		caller.getAssets(Const.RELEASE_NAME, filepath, filepath);
		log.debug("The download file name is {}", filepath);
		System.out.print(filepath);
		return filepath;
	}
}
